name: Load Testing

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to test'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod

jobs:
  load-test:
    name: Run k6 Load Tests - ${{ inputs.environment }}
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}  # Use the selected environment (dev/prod)
    if: ${{ github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Determine Branch
        id: branch
        run: |
          if [ "${{ inputs.environment }}" = "prod" ]; then
            echo "ref=main" >> $GITHUB_OUTPUT
          else
            echo "ref=develop" >> $GITHUB_OUTPUT
          fi
          
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.branch.outputs.ref }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      # Install k6 binary
      - name: Install k6
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg \
            --keyserver hkp://keyserver.ubuntu.com:80 \
            --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | \
            sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6 -y
          k6 version
      
      # Get IMS token for authentication
      # Priority: 1. Refresh Token (dynamic, 14-day validity, auto-rotates)
      #           2. Personal Access Token (static, 24-hour validity)
      - name: Get IMS Token
        id: ims-token
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
        run: |
          # Determine environment-specific variables
          if [ "${{ inputs.environment }}" = "prod" ]; then
            IMS_URL="https://ims-na1.adobelogin.com/ims/token/v3"
            CLIENT_ID="aio-cli-console-auth"
            REFRESH_TOKEN="${{ secrets.IMS_REFRESH_TOKEN_PROD }}"
            PERSONAL_TOKEN="${{ secrets.IMS_TOKEN_PERSONAL_PROD }}"
            REFRESH_SECRET_NAME="IMS_REFRESH_TOKEN_PROD"
          else
            IMS_URL="https://ims-na1-stg1.adobelogin.com/ims/token/v3"
            CLIENT_ID="aio-cli-console-auth-stage"
            REFRESH_TOKEN="${{ secrets.IMS_REFRESH_TOKEN_STAGE }}"
            PERSONAL_TOKEN="${{ secrets.IMS_TOKEN_PERSONAL_STAGE }}"
            REFRESH_SECRET_NAME="IMS_REFRESH_TOKEN_STAGE"
          fi
          
          # Option 1: Try refresh token exchange (preferred - dynamic, 14-day validity)
          if [ -n "$REFRESH_TOKEN" ]; then
            echo "üîÑ Exchanging refresh token for access token (${{ inputs.environment }})..."
            
            RESPONSE=$(curl -s -X POST "$IMS_URL" \
              -H "Content-Type: application/x-www-form-urlencoded" \
              -d "grant_type=refresh_token" \
              -d "client_id=$CLIENT_ID" \
              -d "refresh_token=$REFRESH_TOKEN")
            
            TOKEN=$(echo "$RESPONSE" | jq -r '.access_token')
            NEW_REFRESH=$(echo "$RESPONSE" | jq -r '.refresh_token')
            
            if [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ]; then
              echo "::add-mask::$TOKEN"
              echo "token=$TOKEN" >> $GITHUB_OUTPUT
              echo "‚úÖ User access token obtained via refresh token (premium tier: 1000 calls/min)"
              
              # Auto-update the refresh token secret if we have GH_PAT_TOKEN
              if [ -n "$NEW_REFRESH" ] && [ "$NEW_REFRESH" != "null" ]; then
                echo "::add-mask::$NEW_REFRESH"
                
                if [ -n "$GH_TOKEN" ]; then
                  echo "üîÑ Auto-updating $REFRESH_SECRET_NAME with new refresh token..."
                  
                  # Use GitHub CLI to update the secret
                  if gh secret set "$REFRESH_SECRET_NAME" --body "$NEW_REFRESH" 2>/dev/null; then
                    echo "‚úÖ Refresh token secret updated automatically!"
                  else
                    echo "‚ö†Ô∏è Could not auto-update secret. Manual update may be needed."
                  fi
                else
                  echo "üí° Tip: Add GH_PAT_TOKEN secret (with repo scope) to auto-update refresh tokens"
                fi
              fi
              exit 0
            else
              echo "‚ö†Ô∏è Refresh token exchange failed. Response:"
              echo "$RESPONSE" | jq '.' 2>/dev/null || echo "$RESPONSE"
              echo ""
              echo "Falling back to personal token..."
            fi
          fi
          
          # Option 2: Use personal access token (static, 24-hour validity)
          if [ -n "$PERSONAL_TOKEN" ]; then
            echo "üéØ Using personal Adobe token for ${{ inputs.environment }} (premium tier)"
            echo "::add-mask::$PERSONAL_TOKEN"
            echo "token=$PERSONAL_TOKEN" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # No token available
          echo "‚ùå Error: No token available for ${{ inputs.environment }}!"
          echo ""
          echo "To run load tests, add one of these secrets:"
          echo ""
          echo "Option 1 (Recommended - Dynamic, auto-rotating):"
          if [ "${{ inputs.environment }}" = "prod" ]; then
            echo "  - Secret: IMS_REFRESH_TOKEN_PROD"
          else
            echo "  - Secret: IMS_REFRESH_TOKEN_STAGE"
          fi
          echo "  - Get it: aio auth login --force --verbose"
          echo "  - Copy the refresh_token from the output"
          echo "  - Add GH_PAT_TOKEN secret for auto-rotation"
          echo ""
          echo "Option 2 (Static, 24-hour validity):"
          if [ "${{ inputs.environment }}" = "prod" ]; then
            echo "  - Secret: IMS_TOKEN_PERSONAL_PROD"
          else
            echo "  - Secret: IMS_TOKEN_PERSONAL_STAGE"
          fi
          echo "  - Get it: aio auth login --bare"
          echo ""
          echo "Both give you premium tier (1000 calls/min) for testing!"
          exit 1
      
      # Run basic load test
      - name: Run Load Test on ${{ inputs.environment }}
        env:
          APIM_ENDPOINT: ${{ inputs.environment == 'prod' && vars.APIM_ENDPOINT_PROD || vars.APIM_ENDPOINT_STAGE }}
          IMS_TOKEN: ${{ steps.ims-token.outputs.token }}
          CACHE_ENV: ${{ inputs.environment }}  # For cache isolation
        run: npm run test:load
      
      # Analyze results
      - name: Analyze Results
        if: always()
        run: |
          echo "## Load Test Results - ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check for any result files
          if ls load-test/results/*.json 1> /dev/null 2>&1; then
            echo "### Load Test Summary" >> $GITHUB_STEP_SUMMARY
            for file in load-test/results/*.json; do
              echo "- **Test:** $(basename $file .json)" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              
              # Extract metrics from k6 JSON output (matching k6 textSummary)
              # Test Duration
              DURATION=$(cat "$file" | jq -r 'select(.type == "Point" and .metric == "data_received") | .data.time' 2>/dev/null | head -1)
              
              # Total Requests
              TOTAL_REQS=$(cat "$file" | jq -r 'select(.type == "Point" and .metric == "http_reqs") | .data.value' 2>/dev/null | tail -1)
              
              # Request Rate
              REQ_RATE=$(cat "$file" | jq -r 'select(.type == "Point" and .metric == "http_reqs") | .data.rate' 2>/dev/null | tail -1)
              
              # Average Duration
              AVG_DURATION=$(cat "$file" | jq -r 'select(.type == "Point" and .metric == "http_req_duration") | .data.value' 2>/dev/null | head -1)
              
              # P95 Latency
              P95=$(cat "$file" | jq -r 'select(.type == "Point" and .metric == "http_req_duration" and .data.tags.expected_response == "true") | .data.value' 2>/dev/null | tail -1)
              
              # Success/Error Rates
              FAILED_RATE=$(cat "$file" | jq -r 'select(.type == "Point" and .metric == "http_req_failed") | .data.value' 2>/dev/null | tail -1)
              
              # Token Usage
              TOKENS_USED=$(cat "$file" | jq -r 'select(.type == "Point" and .metric == "tokens_used") | .data.value' 2>/dev/null | tail -1)
              
              # Display metrics (matching k6 textSummary format)
              if [ ! -z "$TOTAL_REQS" ] && [ "$TOTAL_REQS" != "null" ]; then
                TOTAL_REQS_INT=$(echo "$TOTAL_REQS" | xargs printf "%.0f" 2>/dev/null || echo "$TOTAL_REQS")
                echo "  - **Total Requests:** ${TOTAL_REQS_INT}" >> $GITHUB_STEP_SUMMARY
              fi
              
              if [ ! -z "$REQ_RATE" ] && [ "$REQ_RATE" != "null" ]; then
                REQ_RATE_FMT=$(echo "$REQ_RATE" | xargs printf "%.2f" 2>/dev/null || echo "$REQ_RATE")
                echo "  - **Request Rate:** ${REQ_RATE_FMT} req/s" >> $GITHUB_STEP_SUMMARY
              fi
              
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "  **Response Times:**" >> $GITHUB_STEP_SUMMARY
              
              if [ ! -z "$AVG_DURATION" ] && [ "$AVG_DURATION" != "null" ]; then
                AVG_FMT=$(echo "$AVG_DURATION" | xargs printf "%.2f" 2>/dev/null || echo "$AVG_DURATION")
                echo "  - Average: ${AVG_FMT}ms" >> $GITHUB_STEP_SUMMARY
              fi
              
              if [ ! -z "$P95" ] && [ "$P95" != "null" ]; then
                P95_FMT=$(echo "$P95" | xargs printf "%.2f" 2>/dev/null || echo "$P95")
                echo "  - P95: ${P95_FMT}ms" >> $GITHUB_STEP_SUMMARY
              fi
              
              echo "" >> $GITHUB_STEP_SUMMARY
              
              if [ ! -z "$FAILED_RATE" ] && [ "$FAILED_RATE" != "null" ]; then
                SUCCESS_RATE=$(echo "(1 - $FAILED_RATE) * 100" | bc -l 2>/dev/null | xargs printf "%.2f" 2>/dev/null || echo "100.00")
                ERROR_PCT=$(echo "$FAILED_RATE * 100" | bc -l 2>/dev/null | xargs printf "%.2f" 2>/dev/null || echo "0.00")
                echo "  - **Success Rate:** ${SUCCESS_RATE}%" >> $GITHUB_STEP_SUMMARY
                if (( $(echo "$FAILED_RATE > 0.01" | bc -l 2>/dev/null || echo 0) )); then
                  echo "  - **Error Rate:** ‚ùå ${ERROR_PCT}% (threshold: <1%)" >> $GITHUB_STEP_SUMMARY
                else
                  echo "  - **Error Rate:** ‚úÖ ${ERROR_PCT}%" >> $GITHUB_STEP_SUMMARY
                fi
              fi
              
              if [ ! -z "$TOKENS_USED" ] && [ "$TOKENS_USED" != "null" ] && [ ! -z "$TOTAL_REQS" ] && [ "$TOTAL_REQS" != "null" ]; then
                TOKENS_INT=$(echo "$TOKENS_USED" | xargs printf "%.0f" 2>/dev/null || echo "$TOKENS_USED")
                AVG_TOKENS=$(echo "$TOKENS_USED / $TOTAL_REQS" | bc -l 2>/dev/null | xargs printf "%.0f" 2>/dev/null || echo "0")
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "  **Custom Metrics:**" >> $GITHUB_STEP_SUMMARY
                echo "  - Total Tokens Used: ${TOKENS_INT}" >> $GITHUB_STEP_SUMMARY
                echo "  - Avg Tokens/Request: ${AVG_TOKENS}" >> $GITHUB_STEP_SUMMARY
              fi
              
              echo "" >> $GITHUB_STEP_SUMMARY
            done
          else
            echo "- No results found" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Full results available in artifacts." >> $GITHUB_STEP_SUMMARY
      
      # Upload results as artifacts
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: load-test-results-${{ inputs.environment }}
          path: load-test/results/*.json
          retention-days: 10

