name: Load Testing

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to test'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod

jobs:
  load-test:
    name: Run k6 Load Tests - ${{ inputs.environment }}
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Determine Branch
        id: branch
        run: |
          if [ "${{ inputs.environment }}" = "prod" ]; then
            echo "ref=main" >> $GITHUB_OUTPUT
          else
            echo "ref=develop" >> $GITHUB_OUTPUT
          fi
          
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.branch.outputs.ref }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      # Install k6 binary
      - name: Install k6
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg \
            --keyserver hkp://keyserver.ubuntu.com:80 \
            --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | \
            sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6 -y
          k6 version
      
      # Get IMS token using Password Grant
      # This logs in programmatically with user credentials - no stored tokens needed!
      - name: Get IMS Token (Password Grant)
        id: ims-token
        run: |
          echo "Fetching IMS token using Password Grant..."
          
          # Set environment-specific variables
          if [ "${{ inputs.environment }}" = "prod" ]; then
            IMS_ENDPOINT=${{ vars.IMS_TOKEN_URL_PROD }}
            USER_EMAIL="${{ secrets.IMS_USER_EMAIL_PROD }}"
            USER_PASSWORD="${{ secrets.IMS_USER_PASSWORD_PROD }}"
            CLIENT_ID="${{ secrets.IMS_CLIENT_ID_PROD }}"
            CLIENT_SECRET="${{ secrets.IMS_CLIENT_SECRET_PROD }}"
          else
            IMS_ENDPOINT=${{ vars.IMS_TOKEN_URL_STAGE }}
            USER_EMAIL="${{ secrets.IMS_USER_EMAIL_STAGE }}"
            USER_PASSWORD="${{ secrets.IMS_USER_PASSWORD_STAGE }}"
            CLIENT_ID="${{ secrets.IMS_CLIENT_ID_STAGE }}"
            CLIENT_SECRET="${{ secrets.IMS_CLIENT_SECRET_STAGE }}"
          fi
          
          # Validate required secrets
          if [ -z "$USER_EMAIL" ] || [ -z "$USER_PASSWORD" ] || [ -z "$CLIENT_ID" ] || [ -z "$CLIENT_SECRET" ]; then
            echo "Missing required secrets for ${{ inputs.environment }}!"
            exit 1
          fi
          
          # Call IMS Token API with Password Grant
          RESPONSE=$(curl -s --request POST "${IMS_ENDPOINT}" \
            --header 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode 'grant_type=password' \
            --data-urlencode "username=${USER_EMAIL}" \
            --data-urlencode "password=${USER_PASSWORD}" \
            --data-urlencode "client_id=${CLIENT_ID}" \
            --data-urlencode "client_secret=${CLIENT_SECRET}" \
            --data-urlencode 'scope=AdobeID,openid,read_organizations,additional_info.projectedProductContext,additional_info.roles,adobeio_api')
          
          # Extract access token
          TOKEN=$(echo "$RESPONSE" | jq -r '.access_token')
          
          if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
            echo "Failed to get access token!"
            echo "Response: $RESPONSE"
            exit 1
          fi
          
          echo "::add-mask::$TOKEN"
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "Access token obtained successfully (user: ${USER_EMAIL})"
          echo "   This user gets premium tier rate limits (1000 calls/min)"
      
      # Run basic load test
      - name: Run Load Test on ${{ inputs.environment }}
        env:
          APIM_ENDPOINT: ${{ inputs.environment == 'prod' && vars.APIM_ENDPOINT_PROD || vars.APIM_ENDPOINT_STAGE }}
          IMS_TOKEN: ${{ steps.ims-token.outputs.token }}
          CACHE_ENV: ${{ inputs.environment }}  # For cache isolation
        run: npm run test:load
      
      # Analyze results
      - name: Analyze Results
        if: always()
        run: |
          echo "## Load Test Results - ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check for any result files
          if ls load-test/results/*.json 1> /dev/null 2>&1; then
            echo "### Load Test Summary" >> $GITHUB_STEP_SUMMARY
            for file in load-test/results/*.json; do
              echo "- **Test:** $(basename $file .json)" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              
              # Extract metrics from k6 JSON output (matching k6 textSummary)
              # Test Duration
              DURATION=$(cat "$file" | jq -r 'select(.type == "Point" and .metric == "data_received") | .data.time' 2>/dev/null | head -1)
              
              # Total Requests
              TOTAL_REQS=$(cat "$file" | jq -r 'select(.type == "Point" and .metric == "http_reqs") | .data.value' 2>/dev/null | tail -1)
              
              # Request Rate
              REQ_RATE=$(cat "$file" | jq -r 'select(.type == "Point" and .metric == "http_reqs") | .data.rate' 2>/dev/null | tail -1)
              
              # Average Duration
              AVG_DURATION=$(cat "$file" | jq -r 'select(.type == "Point" and .metric == "http_req_duration") | .data.value' 2>/dev/null | head -1)
              
              # P95 Latency
              P95=$(cat "$file" | jq -r 'select(.type == "Point" and .metric == "http_req_duration" and .data.tags.expected_response == "true") | .data.value' 2>/dev/null | tail -1)
              
              # Success/Error Rates
              FAILED_RATE=$(cat "$file" | jq -r 'select(.type == "Point" and .metric == "http_req_failed") | .data.value' 2>/dev/null | tail -1)
              
              # Token Usage
              TOKENS_USED=$(cat "$file" | jq -r 'select(.type == "Point" and .metric == "tokens_used") | .data.value' 2>/dev/null | tail -1)
              
              # Display metrics (matching k6 textSummary format)
              if [ ! -z "$TOTAL_REQS" ] && [ "$TOTAL_REQS" != "null" ]; then
                TOTAL_REQS_INT=$(echo "$TOTAL_REQS" | xargs printf "%.0f" 2>/dev/null || echo "$TOTAL_REQS")
                echo "  - **Total Requests:** ${TOTAL_REQS_INT}" >> $GITHUB_STEP_SUMMARY
              fi
              
              if [ ! -z "$REQ_RATE" ] && [ "$REQ_RATE" != "null" ]; then
                REQ_RATE_FMT=$(echo "$REQ_RATE" | xargs printf "%.2f" 2>/dev/null || echo "$REQ_RATE")
                echo "  - **Request Rate:** ${REQ_RATE_FMT} req/s" >> $GITHUB_STEP_SUMMARY
              fi
              
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "  **Response Times:**" >> $GITHUB_STEP_SUMMARY
              
              if [ ! -z "$AVG_DURATION" ] && [ "$AVG_DURATION" != "null" ]; then
                AVG_FMT=$(echo "$AVG_DURATION" | xargs printf "%.2f" 2>/dev/null || echo "$AVG_DURATION")
                echo "  - Average: ${AVG_FMT}ms" >> $GITHUB_STEP_SUMMARY
              fi
              
              if [ ! -z "$P95" ] && [ "$P95" != "null" ]; then
                P95_FMT=$(echo "$P95" | xargs printf "%.2f" 2>/dev/null || echo "$P95")
                echo "  - P95: ${P95_FMT}ms" >> $GITHUB_STEP_SUMMARY
              fi
              
              echo "" >> $GITHUB_STEP_SUMMARY
              
              if [ ! -z "$FAILED_RATE" ] && [ "$FAILED_RATE" != "null" ]; then
                SUCCESS_RATE=$(echo "(1 - $FAILED_RATE) * 100" | bc -l 2>/dev/null | xargs printf "%.2f" 2>/dev/null || echo "100.00")
                ERROR_PCT=$(echo "$FAILED_RATE * 100" | bc -l 2>/dev/null | xargs printf "%.2f" 2>/dev/null || echo "0.00")
                echo "  - **Success Rate:** ${SUCCESS_RATE}%" >> $GITHUB_STEP_SUMMARY
                if (( $(echo "$FAILED_RATE > 0.01" | bc -l 2>/dev/null || echo 0) )); then
                  echo "  - **Error Rate:** ❌ ${ERROR_PCT}% (threshold: <1%)" >> $GITHUB_STEP_SUMMARY
                else
                  echo "  - **Error Rate:** ✅ ${ERROR_PCT}%" >> $GITHUB_STEP_SUMMARY
                fi
              fi
              
              if [ ! -z "$TOKENS_USED" ] && [ "$TOKENS_USED" != "null" ] && [ ! -z "$TOTAL_REQS" ] && [ "$TOTAL_REQS" != "null" ]; then
                TOKENS_INT=$(echo "$TOKENS_USED" | xargs printf "%.0f" 2>/dev/null || echo "$TOKENS_USED")
                AVG_TOKENS=$(echo "$TOKENS_USED / $TOTAL_REQS" | bc -l 2>/dev/null | xargs printf "%.0f" 2>/dev/null || echo "0")
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "  **Custom Metrics:**" >> $GITHUB_STEP_SUMMARY
                echo "  - Total Tokens Used: ${TOKENS_INT}" >> $GITHUB_STEP_SUMMARY
                echo "  - Avg Tokens/Request: ${AVG_TOKENS}" >> $GITHUB_STEP_SUMMARY
              fi
              
              echo "" >> $GITHUB_STEP_SUMMARY
            done
          else
            echo "- No results found" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Full results available in artifacts." >> $GITHUB_STEP_SUMMARY
      
      # Upload results as artifacts
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: load-test-results-${{ inputs.environment }}
          path: load-test/results/*.json
          retention-days: 10